What “good” looks like (non-negotiables)
Latency: <1.5s to first token for replies; <3s for tool actions.

Reliability: deterministic tool routing + retries; audit log of every action.

Safety: explicit dry-run preview for destructive ops (“Send this email? y/N”).

Privacy: local STT + on-device cache; API keys in macOS Keychain.

Offline mode: minimal Q&A + local tools still work without internet.

High-level architecture (keep it boring = robust)
Menubar client (Swift): global hotkey, push-to-talk, on-screen transcript, confirmation UI.

Local daemon (Python/FastAPI): STT, intent → tools router, memory, tool exec, TTS.

Models:

STT: faster-whisper (small/medium) + VAD.

LLM: start with API (cheap & reliable), later swap to local (Llama-3.1 8B/70B, Qwen2.5).

TTS: macOS AVSpeechSynthesizer (zero-setup) → later Coqui XTTS if you want character voices.

Tools (first wave):

Email (Gmail API or Apple Mail via AppleScript/JXA).

Calendar (Google Calendar or macOS Calendar via EventKit script).

Notes/Todos (Apple Notes via AppleScript; or Todoist API).

System control (Wi-Fi, BT, brightness, app launch) via AppleScript/JXA & Shortcuts.

Browser actions (open URL, search, fill simple forms) via AppleScript + deep links.

Memory: SQLite + embeddings (e.g., text-embedding-3-small or local bge-small). Keep:

User profile, contacts, routines, recent threads (TTL + eviction).

Orchestration: a graph not a loop:

transcribe → classify(intent) → plan → tool calls → summarize → confirm → execute.

Use LangGraph (ideal) or your own tiny state machine.

MVP in 7 days (ship this order)
Day 1 – Mic to text + UI

Menubar app with global hotkey (e.g., ⌘⌥Space) → stream audio → local FastAPI.

Run VAD + faster-whisper → live transcript.

Day 2 – Intent + tool router

Classify to {small_talk, email, calendar, system, search}. If unknown → ask a one-line clarify.

Deterministic routing rules before LLM “creativity”.

Day 3 – Email + Calendar (end-to-end)

OAuth to Gmail (store refresh in Keychain) or Apple Mail AppleScript.

Dry-run UI: show subject/body/recipients, “Send” button.

Day 4 – Memory

Contacts & recent conversations → vector store (SQLite + sqlite-vss or Chroma).

“Remind me to…”, “Who is Sarah from ETH?” works.

Day 5 – Voice out

AVSpeechSynthesizer for instant TTS; stream the assistant reply while executing tools.

Day 6 – Guardrails + audits

Every tool call logged: who/what/when/args/result.

Permission tiers: auto, confirm, blocked per tool & contact.

Day 7 – Polish & tests

20 golden tasks with expected traces. Latency budget + failure retries.
